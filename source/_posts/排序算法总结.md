---
title: 排序算法总结
date: 2019-09-11 10:57:16
tags: 排序算法
categories: 算法
---
记录下常见算法思想以及代码实现。为面试准备！
<!-- more -->

#### 0x01 冒泡排序
##### 1.1 思想

#### 0x02 选择排序
##### 1.1 思想
#### 0x03 插入排序
##### 3.1 思路
(1) 在数组L中，共有n个元素，假设前i-1元素是有序的
(2) 查找出L[i]在L[1]-L[i-1]中的插入位置k。
(3) 将L[k...i-1]中的所有元素全部后移一个位置
(4) 将L[i]复制到L[k]
##### 3.2 代码实现
```java
package com.justnow.insertsort;

import java.util.Arrays;

/**
 * 1、第一次循环，确定前两个元素为有序序列；第二次循环，确定前三个元素为有序序列。。。。。
 * 2、在for循环中，i为该次确定有序序列的最后一个的位数。
 * 3、
 *
 */
public class InsertSort {
    public static void main(String[] args) {
        InsertSort insertSort = new InsertSort();
        int[] array = {2,10,4,8,19,17};
        insertSort.sort(array);
        System.out.println(Arrays.toString(array));

    }

    public void sort(int[] array){
        if(array.length == 0){
            return ;
        }
        for(int i=1; i<array.length; i++){
            int j = i;
            int temp = array[i];
            //如果array[i]小于i之前的有序序列的话，需要将array[i]插入到有序序列的适当位置。如果待插入元素与有序序列的某个元素相等的话，则将待插元素插入到相等元素的后面
            while(j>0&&temp<array[j-1]){
                //通过复制，是数组内容往后移
                array[j] = array[j-1];
                j--;
            }
            //该条件成立，则j为待插入的位置，所以将array[i]中的值放进去
            if(j!=i){
                array[j] = temp;
            }
        }
    }
}
```

#### 0x04 归并排序
总体思想：
- 假定带排序表含有n个记录，则可以看成是n个有序的子表，每个子表的长度为1，然后两两归并，得到n/2个长度为2或1的有序表：再两两归并，......如此重复，直到合并成一个长度为n的有序表为止，这种排序称为2-路归并排序。

递归形式的2-路归并排序算法是基于分治的，其过程如下：
* 分解：将含有n个元素的待排序表分程个含n/2个元素的子表，采用2-路归并排序算法对两个子表递归地进行排序；
* 合并：合并两个已排序的子表得到排序结果。

代码实现：
```java
import java.util.Arrays;

public class MergeSort {
    public static void main(String[] args) {
        MergeSort mergeSort = new MergeSort();
        int[] array = {6, 4, 3, 7, 5, 1, 2};
        System.out.println(Arrays.toString(mergeSort.sort(array)));
    }
    public int[] sort(int[] sourceArray){
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        if(arr.length < 2){
            return arr;
        }
        int middle = (int)Math.floor(arr.length/2);
        int[] left = Arrays.copyOfRange(arr, 0, middle);
        int[] right = Arrays.copyOfRange(arr, middle, arr.length);
        return merge(sort(left), sort(right));
    }
    public int[] merge(int[] left, int[] right){
        int[] result = new int[left.length + right.length];
        int i=0;
        while(left.length > 0 && right.length>0){
            if(left[0] <= right[0]){
                result[i++] = left[0];
                left = Arrays.copyOfRange(left, 1, left.length);
            }else{
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }
        while(left.length > 0){
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        }
        while(right.length > 0){
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }
        return result;
    }
}    
```
数组：int[] array = {6, 4, 3, 7, 5, 1, 2};
第一步：将array分为两个小数组：left={6,4,3,7},right={5,1,2};
第二步：递归将left继续分成小数组，直到其中某一个小数组的长度为1，则表明分解到最小数组
第三步：然后，我们以6和4分别作为merge的参数，该函数的思想非常巧妙：
如果左边数组的第一个元素的值小于右边数组第一个元素的值，那么就将左边数组的第一个值赋值给result数组，然后左边数组要除去左边数组的第一个元素，使用java的Arrays.copyOfRange函数。
该函数后两个参数索引要复制的位置。Array.copyOfRange(left, 1, left.lenght),如果left数组为1，那么将返回一个空数组。
流程如下图所示：
<img src='/img/归并排序分解图.png'>



